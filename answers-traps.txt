1. 在RISC-V汇编中,函数参数通常保存在a0-a7寄存器中
   在main函数对printf的调用中:
   a1寄存器保存了第一个参数12(f(8)+1的结果)
   a2寄存器保存了第二个参数13

2. 在main函数的汇编中找不到对函数f的调用,但可看见调用结果作为常数直接赋给了寄存器a2
   故推测编译器使用了函数内联结合常量传播对其调用进行了优化
   在f函数中亦找不到对函数g的调用,但由汇编代码可知函数g内联于函数f中

3. printf函数的地址在main函数的汇编代码中通过auipc和jalr指令调用
   由指令30: 00000097 auipc ra,0x0
   与指令34: 612080e7 jalr 1528(ra) # 628 <printf>
   可知printf的入口地址为 0x38 + 1528 = 0x628

4. ra存储的是printff返回后应该到的下一条指令的地址, 即0x38

5. Ouput: He110 World
   变量 i 被赋值为 0x00646c72。这是一个 32 位整数
   由于 RISC-V 是小端序，内存中的字节顺序将是：72 6c 64 00
   对应字符分别是 r, l, d, 和 空字符
   printf 函数的第一个参数 "H%x Wo%s" 表示：
   %x 会打印 16 进制数，57616 转换成 16 进制为 e110
   %s 会打印字符串，从 i 的地址开始，实际上会从 r 开始打印，直到遇到空字符。所以会打印出 "rld"
   若RISC-V是大端法,则需要将i调整为0x726C64以获得相同输出,57616只是单纯转为16进制,无需更改

6. 'y='之后会输出一个随机值,这是由于未提供实参给printf,故printf从寄存器a2中获取的是一个垃圾值